
clear;
clc;
close all;

%% PROFILE ON
profile clear;
%profile -memory on
profile on;

%% PARAMETERS

%size of squared patches to train and use the ferns
patchsize=31;
%number of ferns that will be generated by training.
fern_number = 20;
%depth of ferns, where the number of histograms being 2^depth might be
%space critical
fern_depth = 10;
%number of random drawings for determining stable harris points
stable_rand = 50;
%minimum number of occurences of backwarped points in stable_harris needed for
%classification as "stable"
stable_thres = 20;
%number of random warps performed on every patch in training procedure
train_iter = 5000;
%parameters for ransac
%s number of randomly drawn points
ransac_s = 4;
%t distance Threshold
ransac_t = 5;
%T threshold for inliers in random set to terminate ransac
ransac_T = 50;
%N max number of iterations
ransac_N = 50000;

%% SOURCE DATA
image = double(rgb2gray(imread('imagesequence/img1.ppm')));
im=image;
%% TRAINING

%calculate stable points
disp('START calculating stable harris points');%DEBUG
stable_points = stable_harris(im, stable_rand, stable_thres); %XY
disp('stable harris points COMPLETE');%DEBUG
disp(size(stable_points,1));

%init ferns, set number of stable points as potential classes
F = ferns_simple(fern_number, fern_depth, size(stable_points,1));

%train the ferns using patches on stable points 
disp('START training of ferns'); %DEBUG
F.train_many(im, stable_points, patchsize, train_iter);
disp('training of ferns COMPLETE'); %DEBUG

%% SAVE trained fern
fernfile = 'fern.mat';
F.saveFile(fernfile);

%% LOAD trained fern
fernfile = 'fern.mat'
F = ferns_simple.loadFile(fernfile);
F = F.F;

%% NORMALIZE !!!
F.normalize();

%% RECOGNITION
source_im = image;
figure;
imagesc(source_im), colormap gray;
source_rect = [[100 100 1];[size(source_im,2)-100 100 1];[size(source_im,2)-100 size(source_im,1)-100 1];[100 size(source_im,1)-100 1]];
hold on;
plot([source_rect(:,1);source_rect(1,1)],[source_rect(:,2);source_rect(1,2)],'LineWidth',4);

half = floor(patchsize/2);
%DEBUG
%im = image;
for i = 1:5
    rect = source_rect;
    
    im = double(rgb2gray(imread(['imagesequence/img',num2str(i+1),'.ppm'])));
    %im=source_im;
    %points = stable_harris(im, stable_rand, stable_thres-(0.25*stable_thres)); %XY
    points = corner(im,1000);%XY
    disp(size(points))
    
    figure;
    imagesc(im),colormap gray;
    hold on;
    plot(points(:,1),points(:,2),'Xr');
    
    
    im = imfilter(im,fspecial('gaussian',5,0.5));
    impad = padarray(im,[half, half], -1);
    N = imnoise(zeros(size(impad)),'gaussian')*2*255;
    impad(impad(:)==-1) = N(impad(:)==-1);
    
    map_source = zeros(size(points,1),2);
    prob_source = zeros(size(points,1),1);
    map_target = zeros(size(points,1),2);
    
    counter = 1;
    for s = 1:size(points,1)
       p = points(s,:);%XY
       patch = impad(p(2)-half+half:p(2)+half+half,p(1)-half+half:p(1)+half+half);
       %imagesc(patch),colormap gray;
       %drawnow();
       [source_p, prob] = F.recognize(patch);%XY
       if source_p(1) > 0 && source_p(2) > 0 %check for point validity
           map_source(counter,:) = [source_p(1), source_p(2)]; %XY
           map_target(counter,:) = [p(1),p(2)]; % XY
           prob_source(counter) = prob;
           counter = counter+1;
       end
    end
    
    %check for point probability and choose those with the highest
    %probability
    p_source = zeros(size(points,1),2);
    prob_s = zeros(size(points,1),1);
    p_target = zeros(size(points,1),2);
    count = 1;
    for c = 1:counter-1
        found = 0;
        for i = 1:count-1
            if(p_source(i,1) == map_source(c,1) && p_source(i,2) == map_source(c,2))
                found=1;
                if(prob_s(i) < prob_source(c)) 
                  prob_s(i) = prob_source(c);
                  p_source(i,:) = map_source(c,:);
                  p_target(i,:) = map_target(c,:);
               end
               break
            end
        end
        if found == 0
            p_source(count,:) = map_source(c,:);
            p_target(count,:) = map_target(c,:);
            prob_s(count) = prob_source(c);
            count = count+1;
        end
    end
    p_source = p_source([1:count-1],:);
    p_target = p_target([1:count-1],:);
    prob_s = prob_s([1:count-1]);
    disp([p_source,p_target,prob_s]);
    %plot highest probable points (which are chosen for ransac input as target points) as blue
    plot(p_target(:,1),p_target(:,2),'Xb');
    
    
    %disp([map_source map_target])
    
    [dts_max, source_max, target_max, ransac_H] = ransac(p_source,p_target,ransac_t,ransac_T,ransac_s,ransac_N);
    disp(size(target_max))
    plot(target_max(:,1),target_max(:,2),'Og');
    
    ransac_H = ransac_H*(1/ransac_H(3,3));
    disp(ransac_H)
    %ransac_H(:,3) = [0;0;1];
    %ransac_H(3,:) = [0,0,1];
    
    
    %figure;
    %imagesc(im), colormap gray, axis equal tight;
    %hold on;
    %rect = [[1 1 0];[size(source_im,1) 1 0];[size(source_im,1) size(source_im,2) 0];[1 size(source_im,2) 0]]*ransac_H';
    rect = rect*ransac_H';
    rect = rect./repmat(rect(:,3),1,3)
    plot([rect(:,1);rect(1,1)],[rect(:,2);rect(1,2)],'LineWidth',4);
    
    figure;
    imagesc([source_im,im]), colormap gray, axis equal tight;
    hold on;
    p_target_temp = p_target;
    p_target_temp(:,1) = p_target_temp(:,1)+size(source_im,2);
    for z = 1:100%size(p_source,1)
        line([p_source(z,1),p_target_temp(z,1)],[p_source(z,2),p_target_temp(z,2)]);
    end
    
    %disp(rect);
end

%% PROFILE OFF
profile viewer;
profile off;